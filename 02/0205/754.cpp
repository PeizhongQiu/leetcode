/**************************************************************************************************
在一根无限长的数轴上，你站在0的位置。终点在target的位置。
每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。
返回到达终点需要的最小移动次数。

算法思想：
    首先，正负数是对称的。比如说 3 通过 1 + 2 获得，-3 通过 -1 + -2 获得。
    第二，如果 target 刚好可以表示成 1 + 2 + ... + k，则 k 为所需要的最小移动次数。
    第三，另 sum = 1 + 2 + ... + k；sum - k < target 且 sum > target：
        显然，k - 1 不能到达target； 
        另 m = sum - target；
        如果 m 为偶数，则将 m/2 的正负号变换，则 
            1 + ... + (m/2-1) - (m/2) + ... + k = sum - 2 * (m/2) = target，
            因此， k 为所需要的最小移动次数；
        如果 m 为奇数，则不能在 k 步时到达 target，
            因为通过正负号的变换只能减去偶数数值，因此，我们判断 k + 1 和 k + 2 的奇偶性：
            如果 k + 1 为奇数，则 k + 1 为所需要的最小移动次数；
            否则，为 k + 2。  
**************************************************************************************************/


class Solution {
public:
    int reachNumber(int target) {
        int k = 0;
        int sum = 0;
        target = target > 0 ? target : -1 * target;
        while(sum < target) {
            k++;
            sum += k;
        }
        int delta = sum - target;
        if(delta % 2 == 0) return k;
        else {
            if(k % 2) return k + 2;
            else return k + 1;
        }
    }
};